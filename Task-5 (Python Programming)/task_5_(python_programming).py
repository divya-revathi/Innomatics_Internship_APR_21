# -*- coding: utf-8 -*-
"""Task-5 (Python Programming).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SutVMrjObok-UykoQgSgcTrJ0bOzJmYt
"""

#Ques-1 Detecting floatiing point number
# Enter your code here. Read input from STDIN. Print output to STDOUT
import re
    
def validregex(string):
    if(string[0] == '.'):
        return(bool(re.match(r'\.[0-9]+$',string)))   
    else:
        return(bool(re.match(r'[0-9+-][0-9]*\.[0-9]+$',string)))

num = int(input())
for i in range(num):
    print(validregex(input()))

#Ques-2 Re.Split()

regex_pattern = r"[,.]"	# Do not delete 'r'.

import re
print("\n".join(re.split(regex_pattern, input())))

#Ques-3 Group,Groups and Group Dictionary

import re
pattern = r'([0-9a-zA-Z])\1'
inp=input()
match = re.search(pattern, inp)
if match:
    print(match.group(0)[0])
else: 
    print(-1)

#Ques-4 Re.findall() re.finditer()

import re
consonants = 'QWRTYPSDFGHJKLZXCVBNMqwrtypsdfghjklzxcvbnm'
vowels = 'AEIOUaeiou'
pattern = r'(?=[{0}]([{1}]{{2,}})[{0}])'.format(consonants, vowels)
match = re.findall(pattern, input())
if match: print(*match, sep='\n')
else: print(-1)

#Ques-5 Start and End

import re
string = input()
tupel = input()
match = False
for m in re.finditer(r'(?=('+tupel+'))',string):
    match = True
    print((m.start(1),m.end(1)-1))
if match == False:
    print((-1, -1))

#Ques-6 Text Substitution

import re

lines = int(input())
for i in range(0,lines):
   text = input()
   text = re.sub(r"\ \&\&\ "," and ",text)
   text = re.sub(r"\ \|\|\ "," or ",text)
   text = re.sub(r"\ \&\&\ "," and ",text)
   text = re.sub(r"\ \|\|\ "," or ",text)
   print(text)

#Ques-7 Roman Number Validation

regex_pattern = r'^M{0,3}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$'	# Do not delete 'r'.

import re
print(str(bool(re.match(regex_pattern, input()))))

#Ques-8 Validating Phone number

import re
N = int(input())
for i in range(N):
    string = input()
    match = re.search("^[789][0-9]{9}$", string)
    if match:
        print("YES")
    else:
        print("NO")

#Ques-9 Email Parsing

import re

n = int(input())
for i in range(n):
   string = input().strip()
   address = string[string.find("<") + 1:-1]
   if(re.match(r"^[a-zA-Z]+?[a-zA-Z-0-9\-\._]*?@[a-zA-Z]+?\.[a-zA-Z]{1,3}$",address)):
     print(string)

#Ques-10 Hex code

import re
num = int(input())
css_code = [input() for i in range(num)]
css_pattern = '0123456789abcdefABCDEF'
for i in range(num):
    match = re.findall('(?!\A)(#[a-fA-f_0-9]{6}|#[a-fA-f_0-9]{3})', css_code[i])
    if match != []:
        for i in match:
            print(i)

#Ques-11 HTML parser

# Enter your code here. Read input from STDIN. Print output to STDOUT
from html.parser import HTMLParser

class MyHTMLParser(HTMLParser):

    def handle_starttag(self, tag, attrs):
        print("Start : {0}".format(tag))
        for key, val in attrs:
            print("-> {0} > {1}".format(key, val))

    def handle_endtag(self, tag):
        print("End   : {0}".format(tag))

    def handle_startendtag(self, tag, attrs):
        print("Empty : {0}".format(tag))
        for key, val in attrs:
            print("-> {0} > {1}".format(key, val))

parser = MyHTMLParser()
lines = []
n = int(input())
for i in range(n):
    lines.append(str(input()).strip())

parser.feed(''.join(lines))

#Ques-12 HTML Parser 2

from html.parser import HTMLParser

class MyHTMLParser(HTMLParser):
 def handle_data(self, data):
        if ( len(data.strip()) > 0 ):
            print(">>> Data")
            print( data )  

 def handle_comment(self, data):
        arr = data.split('\n')
        if ( len(arr) > 1 ):
            print(">>> Multi-line Comment")
        else:
            print(">>> Single-line Comment")
        for i in arr:
            print( i )
  
  
html = ""       
for i in range(int(input())):
    html += input().rstrip()
    html += '\n'
    
parser = MyHTMLParser()
parser.feed(html)
parser.close()

#Ques-13 detecting HTML tags, attributes

from html.parser import HTMLParser

class Parser(HTMLParser):
    def handle_starttag(self, tag, attrs):
        print(tag)
        for attr in attrs:
            prop,value = attr
            print("-> " + prop + " > " + value)

N=int(input())
string=""
for i in range(N):
    string+= " " + input()

parser = Parser()
parser.feed(string)

#Ques-14 Validating UID

import re

uid_pattern = r'(?!.*(.).*\1)(?=(.)(?!.*\2))(?=.*[A-Z].*[A-Z])(?=.*[0-9].*[0-9].*[0-9])(?=[a-zA-Z0-9]{10}$)'

for _ in range(int(input())):
    user_id = input()
    print('Valid' if re.match(uid_pattern,user_id) else 'Invalid')

#Ques-15 Validating Credit Cards
# Enter your code here. Read input from STDIN. Print output to STDOUT

def validate_card(credit_card):
    if credit_card[0] not in ["4", "5", "6"]:
        return False
    if len(credit_card) != 16 and len(credit_card) != 19:
        return False

    if credit_card[4] == '-' and credit_card[9] == '-' and credit_card[14]:
        credit_card = credit_card[:14] + credit_card[15:]
        credit_card = credit_card[:9] + credit_card[10:]
        credit_card = credit_card[:4] + credit_card[5:]

    if not credit_card.isdigit():
        return False

    for i in range(1, 10):
        if str(i) * 4 in credit_card:
            return False

    return True


n = int(input())
for _ in range(n):
  card_num = input()
  print("Valid" if validate_card(card_num) else "Invalid")

#Ques-16 Validating Postal codes

regex_integer_in_range = r"^[1-9]\d{5}$"	# Do not delete 'r'.
regex_alternating_repetitive_digit_pair = r"(\d)(?=.\1)"	# Do not delete 'r'.


import re
P = input()

print (bool(re.match(regex_integer_in_range, P)) 
and len(re.findall(regex_alternating_repetitive_digit_pair, P)) < 2)

#Ques-17 Matrix Script
#!/bin/python3

import math
import os
import random
import re
import sys




first_multiple_input = input().rstrip().split()

n = int(first_multiple_input[0])

m = int(first_multiple_input[1])

matrix = []

for _ in range(n):
    matrix_item = input()
    matrix.append(matrix_item)

matrix_script = zip(*matrix)
matrix_script = "".join(["".join(i) for i in matrix_script])

matrix_script = re.sub(r'(\w)[^\w]+(\w)', r'\1 \2', matrix_script)
print(matrix_script)